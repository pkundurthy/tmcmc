from iomcmc import *
import numpy as np
import myboundfunc
import sys

def MakeMCMCheader(ModelParams):
    """ Writes a fresh header with parameter names into an MCMC file. """

    param_tagorder = {}
    param_list = []
    for param_names in ModelParams.keys():
        if ModelParams[param_names]['open']:
            param_list.append(param_names)
    
    for el in range(len(param_list)):
        param_tagorder[el] = param_list[el]
        if el == 0:
            headerline = '#'+param_tagorder[el]
        if el > 0:
            headerline = headerline+'|'+param_tagorder[el]
    headerline = headerline+'| istep | frac | acr | chi1 | chi2 |:'
    
    return param_tagorder, headerline

def printMCMCline(param_tagorder,ModelParams,istep,frac,acr,chi1,chi2):
    """ Given ModelParams, the parameter order and other simulation parameters writes lines for the MCMC file. """

    line = ''
        
    Nparams = len(param_tagorder.keys())
    # print param_tagorder
    for el in range(Nparams):
        if el == 0:
            line =\
            str(format(ModelParams[param_tagorder[el]]['value'],\
            ModelParams[param_tagorder[el]]['printformat']))
        if el > 0:
            line = line+'|'+format(ModelParams[param_tagorder[el]]['value'],\
            ModelParams[param_tagorder[el]]['printformat'])
    line = line+'|'+str(format(istep,'.0f'))+'|'+str(frac)+'|'+str(acr)+\
    '|'+str(format(chi1,'.4f'))+'|'+str(format(chi2,'.4f'))+'|:'

    return line

def chisq(fobs,sig,fmodel):
    """ Returns chi**2 given the observed data, errors and the model."""

    # Make sure you're dealing with numpy arrays
    fobs = np.array(fobs)
    sig = np.array(sig)
    fmodel = np.array(fmodel)
    #pylab.plot(sig,'b.')
    #pylab.show()
    # Perform checks to match array sizes
    if len(fobs) != len(fmodel) or len(fobs) != len(sig) or len(fmodel) != len(sig):
        print 'Sizes input arrays do not match.'
        print len(fobs), len(fmodel), len(sig)
        sys.exit()

    # Compute chi**2
    numer = (fobs - fmodel)**2
    denom = (sig**2)
    chisum = numer/denom
    chisq = np.sum(chisum)
    return chisq

def fn_randG(mu,sig):
    """ Returns a random number drawn from a gaussian distribution with mean 'mu' and sigma = 'sig'"""
    return sig*np.random.randn() + mu

def fn_randU(lower,upper):
    """ Returns a random number drawn from a uniform distribution between 'lower' and 'upper' bounds """
    return (upper - lower)*np.random.random_sample() + lower

def AdaptiveMultiplierCheck(ModelParams):
    """ Checks for the single or multi parameters case"""

    paramCount = 0
    for key in ModelParams.keys():
        if ModelParams[key]['open']:
            paramCount += 1

    if paramCount > 1:
        adaptMultiplier = 434.0e0       # For multi-parameter case
    if paramCount == 1:
        adaptMultiplier = 227.3e0       # For 1-parameter case
    if paramCount == 0:
        print 'Error: No Open Parameters Found'
        sys.exit()

    return adaptMultiplier

def StepperFunction(ModelParams,frac):
    """ Perform steps to the model parameters """

    ModelParamsReturn = {}
    for param in ModelParams.keys():
        if ModelParams[param]['open']:
            ModelParamsReturn[param] = {'value':ModelParams[param]['value'] + fn_randG(0,ModelParams[param]['step']*frac),'open':ModelParams[param]['open'],'step':ModelParams[param]['step'],'printformat':ModelParams[param]['printformat']}
        if not ModelParams[param]['open']:
            ModelParamsReturn[param] = {'value':ModelParams[param]['value'],'open':ModelParams[param]['open'],'step':ModelParams[param]['step'],'printformat':ModelParams[param]['printformat']}

    return ModelParamsReturn

def mcmc_mh_adapt(Nsteps,FunctionName,ObservedData,ModelParams,NuisanceData,BoundParams,writeDtCoeffFlag,resumeFlag,OutFile,ShowOutput):
    """ The main MCMC code.
        INPUT:
            Nsteps            - Number of MCMC steps
            FunctionName      - Name of model function in 'myfunc.py'
            ObservedData      - dictionary of observed data, generated by ReadDataFile() or ReadMultiFile()
            ModelParams       - dictionary of model parameters, generated by ReadStartParams()
            NuisanceData      - dictionary of nuisance parameters, generated by ReadDetrendFile()
            BoundParams       - dictionary of bound parameters, generated by ReadBoundsFile()
            writeDtCoeffFlag  - True/False write the coefficients from detrending
            resumeFlag        - True/False check for an existing MCMC OutFile and start where the simulation ended 
            OutFile           - Name of the output file with the MCMC data
            ShowOutput        - boolean, if True prints the MCMC parameters, step, acceptance rate and chisq 
         OUTPUT:
            MCMC data points written into OutFile
    """
    
    exec "from myfunc import %s as ModelFunc" % FunctionName

    ModelParams0 = ModelParams

    if resumeFlag:
        if checkFileExists(OutFile):
            ModelParams, istep, frac, acr \
            = CheckContinue(OutFile,ModelParams0)
            selected_all_count = acr*istep
            rejected_all_count = (1e0-acr)*istep
            write_OR_append = 'a'
            param_tagorder = ReadMCMCheader(OutFile)
            
            # param_tagorder_dummy, headerline = MakeMCMCheader(ModelParams0)
            if istep >= Nsteps:
                print 'MCMC file is complete.'
                return
        else:
            istep = 0
            frac = 1e0
            acr = 0
            selected_all_count = 0
            rejected_all_count = 0
            write_OR_append = 'w'
            param_tagorder, headerline = MakeMCMCheader(ModelParams0)
    else:
        istep = 0
        frac = 1e0
        acr = 0
        selected_all_count = 0
        rejected_all_count = 0
        write_OR_append = 'w'
        param_tagorder, headerline = MakeMCMCheader(ModelParams0)

    # Check the Single/Multi Parameter condition
    adaptMultiplier = AdaptiveMultiplierCheck(ModelParams)

    OutFileObject = open(OutFile,write_OR_append)

    #The Main MCMC algorithm: includes detrending and applying bounds
    ModelData1 = ModelFunc(ModelParams,ObservedData)
    DetrendedData1 = DetrendData(ObservedData,ModelData1,NuisanceData,OutFile,writeDtCoeffFlag)

    trycount_Nadapt = 0
    selected_Nadapt_count = 0

    ModelParams1 = ModelParams.copy()
    chisq1 = chisq(DetrendedData1['all']['y'],DetrendedData1['all']['yerr'],ModelData1['all']['y'])
    Nsteps = float(Nsteps)
    print istep, Nsteps

    while istep < Nsteps:
        if istep > 0: acr = float(selected_all_count)/float(istep)
        if selected_Nadapt_count == 100:
        # adaptive step-size controler applied
        # for every 100 selected steps
            frac = adaptMultiplier*frac/(trycount_Nadapt)
            trycount_Nadapt = 0
            selected_Nadapt_count = 0

        trycount_Nadapt += 1
        withinbounds = False
        ReTryBoundCheck = 0
        while not withinbounds:
            ModelParams2 = StepperFunction(ModelParams1,frac)
            ReTryBoundCheck += 1
            withinbounds = ApplyBounds(ModelParams2,BoundParams)

        ModelData2 = ModelFunc(ModelParams2,ObservedData)
        DetrendedData2 = DetrendData(ObservedData,ModelData2,NuisanceData,OutFile,writeDtCoeffFlag)

        chisq2 = chisq(DetrendedData2['all']['y'],DetrendedData2['all']['yerr'],ModelData2['all']['y'])
        alpha = np.exp( -(0.5e0)*(chisq2-chisq1))

        u = np.random.random_sample()
        
        # printing the header
        if istep == 0:
            print >> OutFileObject, headerline
            #print headerline

        # MCMC step selection algorithm
        
        # a bad step must not be selected -- major failure, quit on occurence
        if chisq1 > 1e8:
            print 'bad chi-sq selection' # if this happens at start of simulation,
            sys.exit()                   # choose parameters that give lower chi-sq
        
        if u <= min(1,alpha):
            ModelParams1 = ModelParams2.copy()
            selected_all_count += 1
            selected_Nadapt_count += 1
            print >> OutFileObject, printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            if ShowOutput: print printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
        else:
            ModelParams1 = ModelParams1.copy()
            rejected_all_count += 1
            print >> OutFileObject, printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            if ShowOutput: print printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
        ModelData1 = ModelFunc(ModelParams1,ObservedData)
        DetrendedData1 = DetrendData(ObservedData,ModelData1,NuisanceData,OutFile,writeDtCoeffFlag)
        chisq1 = chisq(DetrendedData1['all']['y'],DetrendedData1['all']['yerr'],ModelData1['all']['y'])
        #print istep
        istep += 1

    OutFileObject.close()

    print 'MCMC is complete.'

def mcmc_mh_adapt_derived(Nsteps,FunctionName,ObservedData,ModelParams,NuisanceData,BoundParams,writeDtCoeffFlag,resumeFlag,printDerivedFlag,OutFile,DerivedFunctionName,DerivedFile,ShowOutput):
    """ The main MCMC code for checking derived parameters.
        INPUT:
            Nsteps            - Number of MCMC steps
            FunctionName      - Name of model function in 'myfunc.py'
            ObservedData      - dictionary of observed data, generated by ReadDataFile() or ReadMultiFile()
            ModelParams       - dictionary of model parameters, generated by ReadStartParams()
            NuisanceData      - dictionary of nuisance parameters, generated by ReadDetrendFile()
            BoundParams       - dictionary of bound parameters, generated by ReadBoundsFile()
            writeDtCoeffFlag  - True/False write the coefficients from detrending
            resumeFlag        - True/False check for an existing MCMC OutFile and start where the simulation ended
            printDerivedFlag  - True/False for whether a file with derived parameters (Model-dependent) should be printed 
            OutFile           - Name of the output file with the MCMC data
            DerivedFile       - Name of the output file with the Derived parameters
            ShowOutput        - boolean, if True prints the MCMC parameters, step, acceptance rate and chisq 
         OUTPUT:
            MCMC data points written into OutFile
    """
    
    exec "from myfunc import %s as ModelFunc" % FunctionName
    exec "from myderivedfunc import %s as returnDerivedFunc" % DerivedFunctionName


    ModelParams0 = ModelParams.copy()

    if resumeFlag:
        if checkFileExists(OutFile):
            ModelParams, istep, frac, acr = CheckContinue(OutFile,ModelParams0)
            selected_all_count = acr*istep
            rejected_all_count = (1e0-acr)*istep
            write_OR_append = 'a'
            param_tagorder = ReadMCMCheader(OutFile)
            if istep >= Nsteps:
                print 'MCMC file is complete.'
                return
        else:
            istep = 0
            frac = 1e0
            acr = 0
            selected_all_count = 0
            rejected_all_count = 0
            write_OR_append = 'w'
            param_tagorder, headerline = MakeMCMCheader(ModelParams0)
    else:
        istep = 0
        frac = 1e0
        acr = 0
        selected_all_count = 0
        rejected_all_count = 0
        write_OR_append = 'w'
        param_tagorder, headerline = MakeMCMCheader(ModelParams0)

    # Check the Single/Multi Parameter condition
    adaptMultiplier = AdaptiveMultiplierCheck(ModelParams)

    OutFileObject = open(OutFile,write_OR_append)
    if printDerivedFlag: OutDerivedFile = open(DerivedFile,write_OR_append)

    #The Main MCMC algorithm: includes detrending and applying bounds
    ModelData1 = ModelFunc(ModelParams,ObservedData)
    DetrendedData1 = DetrendData(ObservedData,ModelData1,NuisanceData,OutFile,writeDtCoeffFlag)

    trycount_Nadapt = 0
    selected_Nadapt_count = 0

    ModelParams1 = ModelParams.copy()
    chisq1 = chisq(DetrendedData1['all']['y'],DetrendedData1['all']['yerr'],ModelData1['all']['y'])
    keyList = {}
    while istep < Nsteps:
        if istep > 0: acr = float(selected_all_count)/float(istep)
        if selected_Nadapt_count == 100:
        # adaptive step-size controler applied
        # for every 100 selected steps
            frac = adaptMultiplier*frac/(trycount_Nadapt)
            trycount_Nadapt = 0
            selected_Nadapt_count = 0

        trycount_Nadapt += 1
        withinbounds = False
        ReTryBoundCheck = 0
        while not withinbounds:
            ModelParams2 = StepperFunction(ModelParams1,frac)
            ReTryBoundCheck += 1
            withinbounds = ApplyBounds(ModelParams2,BoundParams)

        ModelData2 = ModelFunc(ModelParams2,ObservedData)
        DetrendedData2 = DetrendData(ObservedData,ModelData2,NuisanceData,OutFile,writeDtCoeffFlag)

        chisq2 = chisq(DetrendedData2['all']['y'],DetrendedData2['all']['yerr'],ModelData2['all']['y'])
        #print istep, chisq1, chisq2, acr, frac
        alpha = np.exp( -(0.5e0)*(chisq2-chisq1))

        u = np.random.random_sample()
        
        #printing the header
        if istep == 0:
            print >> OutFileObject, headerline
            #print headerline

        #MCMC step selection algorithm
        if chisq1 > 1e8:
            print 'bad chi-sq selection' # if this happens at start of simulation,
            sys.exit()                   # choose parameters that give lower chi-sq
        
        if u <= min(1,alpha):
            ModelParams1 = ModelParams2.copy()
            selected_all_count += 1
            selected_Nadapt_count += 1
            print >> OutFileObject, printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            if ShowOutput: print printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            DerivedLine,keyList = returnDerivedFunc(ModelParams1,istep,keyList)
            if printDerivedFlag: print >> OutDerivedFile, DerivedLine
        else:
            ModelParams1 = ModelParams1.copy()
            rejected_all_count += 1
            print >> OutFileObject, printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            if ShowOutput: print printMCMCline(param_tagorder,ModelParams1,istep,frac,acr,chisq1,chisq2)
            DerivedLine,keyList = returnDerivedFunc(ModelParams1,istep,keyList)
            if printDerivedFlag: print >> OutDerivedFile, DerivedLine
            
        ModelData1 = ModelFunc(ModelParams1,ObservedData)
        DetrendedData1 = DetrendData(ObservedData,ModelData1,NuisanceData,OutFile,writeDtCoeffFlag)
        chisq1 = chisq(DetrendedData1['all']['y'],DetrendedData1['all']['yerr'],ModelData1['all']['y'])
        #print istep
        istep += 1

    OutFileObject.close()

    print 'MCMC is complete.'

def DetrendData(ObservedData,ModelData,NuisanceData,OutFile,writeDtCoeffFlag):
    """ Performs Detrending of Observed Data using Nuisance parameters.
        Writes Coefficients if needed.
    """

    # Check if Detrending is required
    if not NuisanceData['GlobalSwitch']:
        return ObservedData
    else:
        DetrendedData = {}
        if writeDtCoeffFlag:
            DtCoeffFile = open('DTCOEFF.'+OutFile,'a')
        for key in NuisanceData.keys():
            if not key == 'GlobalSwitch':
                x0 = ObservedData[key]['x']
                y0 = ObservedData[key]['y']
                yerr0 = ObservedData[key]['yerr']
                ymod0 = ModelData[key]['y']
                # Normalizing by Model
                yi0 = np.array(y0)/np.array(ymod0)
                yierr0 = np.array(yerr0)/np.array(ymod0)
                B_MAT = yi0/yierr0      # dependent variable divided by errors
                lenDataN = len(yierr0)
                Npar = 0
                A_MAT = np.array([])    # define the Design Matrix
                nuisance_paramlist = {}
                # Populate the Design Matrix
                for nuisance_key in NuisanceData[key]['dtparams'].keys():
                    if NuisanceData[key]['dtparams'][nuisance_key]['used']:
                        nuisance_paramlist[Npar] = nuisance_key
                        Npar += 1
                        IndependentVariable = \
                        np.array(NuisanceData[key]['dtparams'][nuisance_key]['data'])
                        if Npar == 1:
                            #print lenDataN, np.shape(IndependentVariable), np.shape(yierr0)
                            A_MAT = (IndependentVariable/yierr0).reshape(lenDataN,1)
                            Xi = IndependentVariable.reshape(lenDataN,1)
                        else:
                            A_MAT = np.hstack((A_MAT,(IndependentVariable/yierr0).reshape(lenDataN,1)))
                            Xi = np.hstack((Xi,IndependentVariable.reshape(lenDataN,1)))
                #print np.shape(A_MAT), np.shape(B_MAT)
                coeff_dict = {}
                if Npar != 0:
                    shape_Xi = np.shape(Xi)
                    B_MAT = B_MAT.reshape(np.shape(B_MAT)[0],1)
                    ones = (np.zeros(shape_Xi[0])+1e0).reshape(shape_Xi[0],1)
                    zeros = ones - 1e0
                    A_MAT = np.hstack( (A_MAT,zeros) )
                    Xi = np.hstack((Xi,zeros))
                    #print np.shape(A_MAT), np.shape(Xi)
                    a_coeff = LinearLeastSq_coeff(A_MAT,B_MAT)
                    a_coeff_list = map(None,a_coeff.getA1())
                    if writeDtCoeffFlag:
                        printl1 = '## ['+key+']'
                        printl2 = '['+key+']'
                        for idkey in nuisance_paramlist.keys():
                            printl1 = printl1+nuisance_paramlist[idkey]+'|'
                            printl2 = printl2+str(a_coeff_list[int(idkey)])+'|'
                        printl1 = printl1+':'
                        printl2 = printl2+':'
                        print >> DtCoeffFile, printl1
                        print >> DtCoeffFile, printl2
                    XiMatrix = np.matrix(Xi)
                    a_coeffMatrix = np.matrix(a_coeff[:,0])
                    CorrectionFunction = XiMatrix*a_coeffMatrix
                    CorrectionFunction = CorrectionFunction.getA1()
                    a_coeffOut = a_coeffMatrix.getA1()
                    DetrendedData0 = (y0 - CorrectionFunction + 1e0)
                    for el in nuisance_paramlist.keys():
                        coeff_dict[nuisance_paramlist[el]] = a_coeff[el,0]
                    coeff_dict['const'] = a_coeff[-1,0]
                if Npar == 0:
                    CorrectionFunction = np.zeros(len(ymod0))
                    DetrendedData0 = (y0 - CorrectionFunction + 1e0)
                DetrendedData[key] = {'x':x0,'y':DetrendedData0,'yerr':yerr0,'correction':CorrectionFunction,'dtcoeff':coeff_dict}
                #print key, coeff_dict
        #print a_coeffOut
        all_detrended_x = []
        all_detrended_y = []
        all_detrended_yerr = []
        all_detrended_correction = []
        Ntags = len(ObservedData['all']['tagorder'].keys())
        for tag in np.array(range(Ntags))+1:
            transit_tag = ObservedData['all']['tagorder'][tag]
            all_detrended_x = np.hstack((all_detrended_x,DetrendedData[transit_tag]['x']))
            all_detrended_y = np.hstack((all_detrended_y,DetrendedData[transit_tag]['y']))
            all_detrended_yerr = np.hstack((all_detrended_yerr,DetrendedData[transit_tag]['yerr']))
            all_detrended_correction = np.hstack((all_detrended_correction,DetrendedData[transit_tag]['correction']))

        DetrendedData['all'] = {'x':all_detrended_x,'y':all_detrended_y,'yerr':all_detrended_yerr,'correction':all_detrended_correction,'tagorder':ObservedData['all']['tagorder']}

        return DetrendedData

def LinearLeastSq_coeff(A,B):
    """ Performs Linear Least-Squares Minimization given the design matrix A and
        the observed data weighted by the errors (B).
        See Chapter 15.4 in Numerical Recipies in C (Second Edition)
    """

    shapeA = np.shape(A)
    if len(shapeA) == 1:
        lengthID = 0
    if len(shapeA) == 2:
        lengthID = 1
    AMatrix = np.matrix(A)
    BMatrix = np.matrix(B)
    AMatrixTranspose = AMatrix.T
    AlphaMatrix = AMatrixTranspose*AMatrix
    BetaMatrix = AMatrixTranspose*BMatrix
    OutSolution = np.linalg.lstsq(AlphaMatrix,BetaMatrix)  # solving for linear-least square parameters
    return OutSolution[0]

""" The Bounds Checking function """
def ApplyBounds(ModelParams,BoundParams):
    """ The main function which test if all the parameters are within the required bounds. Parameter values are taken from ModelParams and the bounding conditions are set in the BoundParams.
    
    Input - the tmcmc format ModelParams dictionary and the tmcmc format BoundParams dictionary
    Output - a Boolean True or False denoting whether the parameters are within bounds
    """
    
    withinbound = True
    boundchecklist = []
    for key in BoundParams.keys():
        if BoundParams[key]['open']:
            exec "boundFlag = myboundfunc.%s(ModelParams)" % (key)
            boundchecklist.append(boundFlag)

    for el in boundchecklist:
        if not el:
            withinbound = False

    return withinbound
